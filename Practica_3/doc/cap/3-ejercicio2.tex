En esta sección abordaremos el problema del viajante de comercio. Dado que
se trata de un algoritmo de clase NP, es prácticamente inviable encontrar 
un algoritmo que encuentre la solución óptima en un tiempo razonable.

Por tanto, para abordar este problema se emplearán 3 heurísticas diferentes que,
si bien no siempre encuentran la solución óptima, determinan soluciones 
aceptables en tiempos razonables. Para cada una de
estas heurísticas se comparará su rendimiento en un conjunto de prueba,
midiendo los tiempos de ejecución. 

\subsection{Descripción de las heurísticas}

En esta sección se realizará una descripción de cada heurística que hemos 
empleado, incluyendo tanto algoritmos, implementación como casos de ejemplo.
Dos heurísticas han sido proporcionados por los profesores: el \textit{vecino
más cercano} e \textit{inserción}, mientras que la tercera es de
elaboración propia.

\subsubsection{Vecino más cercano}

La filosofía que gobierna esta heurística es bastante sencilla. La idea 
radica en ir insertando ciudades en el conjunto de solución $S$, de manera
que para decidir la ciudad $c_{i+1}$ que se insertará se escoge aquella que
dista la menor distancia de la ciudad $c_i$ (para $c_0$ se escoge
un nodo al azar). Esta idea queda resumida en el Algoritmo~\ref{alg:vec_cercano}. 

\begin{algorithm}
    \caption{An algorithm with caption}\label{alg:vec_cercano}
    \KwData{$ L (lista de arcos ordenados)$}
    \KwResult{$y = x^n$}
    $y \gets 1$\;
    $X \gets x$\;
    $N \gets n$\;
    \While{$N \neq 0$}{
      \eIf{$N$ is even}{
        $X \gets X \times X$\;
        $N \gets \frac{N}{2}$ \Comment*[r]{This is a comment}
      }{\If{$N$ is odd}{
          $y \gets y \times X$\;
          $N \gets N - 1$\;
        }
      }
    }
\end{algorithm}

\subsubsection{Inserción económica}

En este caso para obtener la solución final se fijan $c_1,c_2,c_3$ ciudades
(siguiendo las indicaciones de la práctica, se han
escogido las ciudades situadas más al norte, este y oeste). 
Posteriormente,
para decidir la ciudad $c_{i+1}$ que se insertará en el conjunto de solución,
se elige aquella que, al insertarse en un determinado arco del ciclo 
$0 \leq j \leq i$, minimice la variación en el ciclo formado por las ciudades
$c_1,c_2,\cdots,c_{i}$. Dicha ciudad se añade intercalado entre las ciudades
$c_{j},c_{j+1}$. El algoritmo asociado a esta heurística se encuentra en 
Algoritmo~\ref{alg:insercion}. 

\begin{algorithm}[H]
  \caption{Algoritmo auxiliar para la inserción. InsercionEconomica}\label{alg:insercion-aux-1}
  \begin{minipage}{0.92\textwidth}
    \textbf{Parámetro}: ady (matriz de adyacencia)

    \textbf{Parámetro}: ciclo (solución parcial)

    \textbf{Parámetro}: pos
  \end{minipage}

  $(c_{ini}, c_{fin}) = (-1,-1)$\;
  $var = \infty$\;
  ind = -1\;

  \For{i desde 0 hasta ciclo.size-1}{
    $(c_a, c_b)$ = ciclo[i]\;
    nueva\_variacion = $ady[c_a][c_i] + ady[c_i][c_b] - ady[c_a][c_b]$\;

    \If{nueva\_variacion $<$ variacion}{
      $(c_{ini}, c_{fin}) = (c_a, c_b)$\;
      ind = i\;
    }
  }
  
  \Return{$(ind, pos, var)$}
\end{algorithm}

\begin{algorithm}[H]
  \caption{Algoritmo auxiliar para la inserción. CiudadEconomica (se usa el Algoritmo~\ref{alg:insercion-aux-1})}\label{alg:insercion-aux-2}
  \begin{minipage}{0.92\textwidth}
    \textbf{Parámetro}: ady (matriz de adyacencia)

    \textbf{Parámetro}: ciclo (solución parcial)

    \textbf{Parámetro}: banderas
  \end{minipage}

  ind = 0\;

  \While{banderas[ind] e ind valido}{
    ind++\;
  }

  $(ind_a, pos_a, var_a)$ = InsercionEconomica(ady,ciclo,ind)\;

  \For{i desde ind+1 hasta ady.tamaño}{
    \If{banderas[i] no activado}{
      $(ind_n, pos_n, var_n)$ = InsercionEconomica(ady, ciclo, i)\;
      % $(c_{n}, c_{n+1}, var_n)$ = InsercionEconomica(ady, ciclo, i)\;

      \If{$var_n < var_a$ }{
        $(ind_a, pos_a, var_a)$ = $(ind_n, pos_n, var_n$\;
      }
    }
  }

  \Return{$(c_{ind_a},pos_a)$}
  
\end{algorithm}

El Algoritmo~\ref{alg:insercion-aux-1} y el Algoritmo~\ref{alg:insercion-aux-2}
se emplean como funciones auxiliales sobre los que se basa el algoritmo maestro. 

Se presenta el algoritmo máster.

\begin{algorithm}[H]
    \caption{Algoritmo basado en inserción. CicloInsercionEconomica (se usan los algoritmos 
    auxiliares Algoritmo~\ref{alg:insercion-aux-1} y Algoritmo~\ref{alg:insercion-aux-2})}\label{alg:insercion}
    \begin{minipage}{0.92\textwidth}
      \textbf{Parámetro}: puntos (vector de posiciones)
      
      \textbf{Parámetro}: ady (matriz de adyacencia)
    \end{minipage}
    % $Ady = MatrizAdyacencia(C)$\;
    % $N = C.\text{tamaño}$\;
    % $S = []$\;
    % $S$.añadir($c_\alpha$), con $\alpha \in \{j \in \mathbb N : c_j.x \geq c.x, \forall c \in C\}$ \Comment*[r]{Ciudad más al este}
    % $S$.añadir($c_\beta$), con $\beta \in \{j \in \mathbb N : c_j.x \leq c.x, \forall c \in C\}$ \Comment*[r]{Ciudad más al oeste}
    % $S$.añadir($c_\gamma$), con $\gamma \in \{j \in \mathbb N : c_j.y \geq c.y, \forall c \in C\}$ \Comment*[r]{Ciudad más al norte}
    % \While{$S.\text{tamaño} \leq N$}{
    %   $(i,pos) = CiudadEconomica(C, S, Ady)$\;
    %   $S$.insertar(pos, $c_i$)\;
    %   $C$.quitar($c_i$)\;
    % }

    ciclo = []\;

    N = puntos.tamaño;
    Banderas = []\;

    \For(){i desde 0 hasta N-1}{
      Banderas.insertar(false)
    }

    \Comment*{Añadimos las tres primeras ciudades}

    ind\_este = IndCiudadEste(puntos);
    banderas[ind\_este] = true\;

    ind\_oeste = IndCiudadOeste(puntos);
    banderas[ind\_oeste] = true\;

    ind\_este = IndCiudadNorte(puntos);
    banderas[ind\_norte] = true\;


    ciclo.insertar((ind\_este, ind\_oeste));
    ciclo.insertar((ind\_oeste, ind\_norte))\;
    ciclo.insertar((ind\_norte, ind\_este))\;

    % $S$.añadir(puntos[ind_este])\;
    % $S$.añadir(puntos[ind_oeste])\;
    % $S$.añadir(puntos[ind_norte])\;

    \Comment*{Añadimos el resto de ciudades}
    \For(){i desde 3 hasta N-1}{
      $(c_i,pos)$ = CiudadEconomica(ady, ciclo, banderas)\;
      $(c_j, c_{j+1})$ = s[pos]\;
      banderas[$c_i$] = true\;
      ciclo.insertar(pos, $(c_i,c_{j+1})$)\;
      ciclo.insetar(pos, $(c_j,c_i)$)\;
    }
    \Return{ciclo}
\end{algorithm}

El código asociado al algoritmo Algoritmo~\ref{alg:insercion} viene especificado
a continuación, en el Código~\ref{cod:tsp1}. 

\lstinputlisting[label={cod:tsp1}, firstline=119, lastline=300, language=C++,
caption=Implementación del algoritmo de inserción en TSP.]{../src/tsp.cpp}

\subsubsection{Heurística basada en el algoritmo de Kruskal} 

La siguiente heurística de elaboración propia se basa en la idea utilizada en el \textbf{algoritmo de Kruskal} para la determinación del AGM. 

Dado el conjunto de $n$ ciudades conectadas entre sí, se crea un grafo $G$ que represente la red de ciudades, y un grafo $S$ que en el momento de su construcción contenga únicamente las ciudades o nodos de $G$, pero sin ninguna conexión entre nodos.

A continuación, ordenamos los arcos de $G$ en orden creciente según la ponderación del arco (sin incluir lazos, es decir, ciclos entre un nodo y el mismo). Esta \textbf{lista de arcos}, $L$, constituye nuestro \textbf{conjunto de candidatos}, es decir en cada etapa del algoritmo, \textbf{la función de selección escoge el arco de menor ponderación} (primer elemento de la lista), y seguidamente comprobamos si el arco escogido cumple las condiciones de factibilidad, si las cumple será insertado en $S$, y en caso contrario ese arco será descartado de la solución. 

En cuanto a la factibilidad de un candidato, tenemos \textbf{dos condiciones de factibilidad}. La primera consiste en comprobar que los nodos entre los que vamos a insertar el arco cumplen la siguiente condición: el nodo origen debe de tener como máximo un nodo incidente, y no puede tener un arco adyacente, y el nodo destino debe de tener como máximo un arco adyacente y no debe tener un arco incidente. Con esta condición nos garantizamos parte de la construcción de un circuito en el grafo $S$, de forma que \textbf{cada nodo del grafo solución tenga una única entrada y una única salida}. La segunda condición consiste en comprobar que al añadir el arco candidato al grafo solución $S$ \textbf{no se formen ciclos}, aunque esta condición no se comprueba en la última iteración del algoritmo, ya que debe formarse un circuito en la última etapa.

El algoritmo terminará cuando se hayan insertado tantas aristas como nodos tiene $S$, formando un circuito Hamiltoniano. La elección del arco de menor coste entre los que hay disponibles responde a la idea de intentar minimizar la \textbf{función objetivo}, que mide el coste total del circuito.

\begin{algorithm}
	\caption{Algoritmo basado en Kruskal}\label{alg:bas_kruscal}
	\begin{minipage}{0.92\textwidth}
		\textbf{Parámetro}: L (lista de arcos ordenada)
		
		\textbf{Parámetro}: nNodos (número de nodos/ciudades)
		
		\textbf{Parámetro}: grafoSol (grafo con la solución, parámetro de entrada/salida)
	\end{minipage}
	nArcosInsertados = 0\;
	\While{narcosInsertados $<$ nNodos \&\& !L.vacia()}{
		arcoCandidato = L.frente()\;
		L.eliminarFrente()\;
		
		\eIf{$N$ is even}{
			$X \gets X \times X$\;
			$N \gets \frac{N}{2}$ \Comment*[r]{This is a comment}
		}{\If{$N$ is odd}{
				$y \gets y \times X$\;
				$N \gets N - 1$\;
			}
		}
	
	}
\end{algorithm}



 





