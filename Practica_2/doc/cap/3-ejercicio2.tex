El problema que se nos presenta es, dados $k$ vectores ordenados de menor a mayor,
cada uno con $n$ elementos, combinarlos en un único vector con todos los elementos
ordenados de la misma manera. Al igual que antes, presentamos una solución obvia y
otra empleando un algoritmo Divide y Vencerás. 

\subsection{Caso obvio}

En este caso una alternativa es ir iterando sobre cada vector, añadiendo los elementos
del vector de forma ordenada sobre un acumulador. Ello queda ilustrado en la figura
\ref{fig:2a-obvio}, donde primer se unen los vectores que están en rojo y morado para,
a continuación, unir ese resultado con el vector en verde, dando como resultado
un vector global ordenado. 

\begin{figure}
    \centering
    \includegraphics[scale=0.87]{img/orden_2a.pdf}
    \caption{Esquema de funcionamiento del algoritmo de 
    mezcla obvio. Elaboración propia.}
    \label{fig:2a-obvio}
\end{figure}

\subsubsection{Pseudocódigo}

\lstinputlisting[caption=Pseudocódigo asociado a la mezcla 
ordenada de vectores ordenados en el caso obvio., 
label={alg:2a-obvio}]{listing/ejer2a-pseudo-obvio.txt}

\subsubsection{Implementación}

\lstinputlisting[firstline=81, lastline=130, language=C++,
caption=Implementación del algoritmo \ref{alg:2a-obvio}.]{../src/ejercicio-2-mezcla.cpp}

\subsubsection{Análisis de Eficiencia}

En primer lugar, analizamos la \textbf{eficiencia teórica}. En este caso,
el tamaño del problema depende tanto del número de componentes
de los vectores $n$ como del número de vectores $k$ que hemos
considerado. 

Analizando el algoritmo auxiliar UNIFICA de \ref{alg:2a-obvio}, tenemos que el 
número de operaciones que se realiza es independiente
del número de vectores $k$ a considerar, por lo que queda
acotada por una constante. Por su parte, el número de componentes de los
vectores sí influye en el número de operaciones, pues en el ciclo while se recorre completamente
el uno de los vectores y parcialmente la otra, siendo las restantes componentes recorridas
a continuación, por lo que se realizan $cn$ operaciones elementales,
con $c \in \mathbb N$ constante. 

Notemos que el número de operaciones que
se realizan es independiente de los valores de los vectores,
por lo que el mejor caso y el peor caso tienen el mismo orden
de eficiencia. Por tanto, tenemos que su eficiencia es $\theta(n)$. 

% \begin{wraptable}{b}{0.3\linewidth}
\begin{table}
    \footnotesize
    \centering
    \begin{tabular}{|r|r|}
        \hline
        $N$ & $T$ $(\mu s)$ \\
        \hline
        1 & 0.0031 \\ 
        51 & 0.0100 \\ 
        101 & 0.0106 \\ 
        151 & 0.0135 \\ 
        201 & 0.0150 \\ 
        251 & 0.0209 \\ 
        301 & 0.0245 \\ 
        351 & 0.0268 \\ 
        401 & 0.0283 \\ 
        451 & 0.0337 \\ 
        501 & 0.0359 \\ 
        551 & 0.0445 \\ 
        601 & 0.0498 \\ 
        651 & 0.0475 \\ 
        701 & 0.0537 \\ 
        751 & 0.0536 \\ 
        801 & 0.0592 \\ 
        851 & 0.0659 \\ 
        901 & 0.0681 \\ 
        951 & 0.0683 \\ 
        \hline
    \end{tabular}
    \caption{Tiempos de ejecución para el algoritmo \ref{alg:2a-obvio}.}
    \label{tab:2a-obvio-n}
% \end{wraptable}
\end{table}

Para el algoritmo AGRUPA de \ref{alg:2a-obvio}, que es el que nos interesa,
tenemos que cada iteración del bucle realiza $an + b$, con $a,b \in \mathbb N$ constantes,
operaciones adicionales respecto al anterior,
realizándose un total de $k$ iteraciones. Por tanto, llamando $T(n)$ al número de
operaciones elementales realizadas por el algoritmo, obtenemos la 
expresión \ref{eq:2a-eficiencia}. 

\begin{equation} \label{eq:2a-eficiencia}
    \begin{split}
        T(n) & = (an + b) + 2(an + b) + 3(an + b) + \cdots + k(an + b) \\
             & = (an + b)\sum_{j=1}^k j = (an + b) \frac{k(k+1)}{2} \Rightarrow \boxed{T(n) \in O(nk^2)}
    \end{split}
\end{equation}

Para la \textbf{eficiencia híbrida}, se han tomado dos series de datos pues la eficiencia depende de 2 parámetros.
De esta manera, manteniendo $k$ constante se ha obtenido la tabla \ref{tab:2a-obvio-n}. 
Para $n$ constante, obtenemos la tabla ??. 

% En la gráfica \ref{fig:2a-obvio-graph} hemos representado los puntos experimentales, así como la función
% de ajuste lineal asociada, con \textbf{función de ajuste} $f$ y \textbf{coeficiente de regresión}
% $R^2$ especificada en \ref{eq:2a-ajuste}. 

% \begin{equation}
%     \boxed{f(x) = 7.0629 x + 0.0030, R^2 = 0.9890}
%     \label{eq:2a-ajuste}
% \end{equation}

% \begin{figure}
%     \centering
%     \includegraphics[scale=0.76]{img/ejercicio-2-obvio-graph.pdf}
%     \caption{Gráfica de tiempos de ejecución para el caso obvio, 
%     con f(x) y coeficiente de regresión especificada por \ref{eq:2a-ajuste}.}
%     \label{fig:2a-obvio-graph}
% \end{figure}