El \textbf{problema} que se nos plantea es, dado un vector ordenado (de forma no decreciente) de $n$ números enteros $v$, todos 
distintos, determinar si existe un índice $i$ tal que $v[i] = i$ y 
encontrarlo en ese caso. Para resolver el problema hemos utilizado dos algoritmos, uno básico basado en 
la búsqueda lineal, y otro basado en la técnica de Divide y Vencerás. 

\subsection{Vector con valores no repetidos}

En primer lugar, abordamos el problema para vectores con valores no repetidos. Para esta parte
caben destacar los lemas \ref{lem:1} y \ref{lem:2}. En esta subsección, $v$ será un vector ordenado con
valores no repetidos con componentes enteras. 

% El último algoritmo se ha desarrollado a partir de un análisis detallado del 
% problema, a partir del cual hemos conseguido demostrar las siguientes proposiciones:

\begin{lemma}
    \label{lem:1}
    Sea i con $0 \leqslant i < n$ fijo, tal que $v[i]=i+k$, con $k \in \mathbb N$. 
    Entonces $v[j] \neq j$, $\forall j \in \mathbb N$ con $i < j < n$. 
\end{lemma}

\begin{proof}
    Razonemos por contradicción. Supongamos que para $j > i$ se 
    cumple que $v[j]=j$, esto es, $\exists m \in \mathbb N$ tal que $j=i+m$. Como el 
    vector está ordenado en orden no decreciente sin repetidos, como mínimo un elemento
    difiere en una unidad del elemento siguiente. En consecuencia,  $v[j] \geq v[i]+m$. 
    Como por hipótesis $v[i]=i+k$, tendríamos que $v[j] \geq i+k+m$, pero $i=j-m$, entonces 
    $v[j] \geq j-m+k+m=j+k > j$, lo que es contradictorio pues habíamos supuesto que $v[j]=j$. Por tanto, no 
    existe ningún $j > i$ tal que $v[j]=j$.
\end{proof}

\begin{lemma}
    \label{lem:2}
    Sea i con $0 < i < n$ fijo, tal que $v[i]=i-k$ con 
    $k \in \mathbb N$. Entonces $v[j] \neq j$,  $\forall j$ con $0 \leqslant j < i$. 
\end{lemma}

\begin{proof}
    Razonemos por contradicción. Supongamos que para $j < i$ se 
    cumple que $v[j]=j$, entonces $\exists m \in \mathbb N$ tal que $j=i-m$. Como el 
    vector está ordenado en orden no decreciente sin repetidos, como mínimo un elemento
    difiere en una unidad del elemento siguiente. En consecuencia,  $v[j] \leq v[i]-m$. 
    Como por hipótesis $v[i]=i-k$, tendríamos que $v[j] \leq i-k-m$, pero $i=j+m$, entonces 
    $v[j] \leq j+m-k-m=j-k < j$, lo que es contradictorio pues habíamos supuesto que $v[j]=j$. Por tanto, no 
    existe ningún $j<i$ tal que $v[j]=j$.
\end{proof}

\subsubsection{Caso obvio}

En este caso el algoritmo de búsqueda del índice se basa en la búsqueda lineal. 

\subsubsubsection{Pseudocódigo}

\lstinputlisting[caption=Pseudocódigo asociado al caso obvio., label={alg:1a-obvio}]{listing/ejer1a-pseudo-obvio.txt}

\subsubsubsection{Implementación}

\lstinputlisting[language=C++, firstline=93, lastline=106, caption=Implementación en C++ 
del algoritmo basado en la búsqueda lineal., label={cod:1a-obvio}]{../src/ejercicio-1-comp-fija-no-repetidos.cpp} 

\subsubsubsection{Análisis de Eficiencia}

Las dos primeras líneas son sentencias de asignación $O(1)$, luego podemos acotarlas por una constante $c$. 
Posteriormente, nos encontramos con un bucle while, que en el peor de los casos (no se encuentra la posición buscada) 
recorre todas las componentes del vector, en cuyo cuerpo encontramos sentencias $O(1)$, y las acotamos por una constante $t$.
Entonces llamando $n$ a la longitud del vector donde realizamos la búsqueda (el tamaño del problema) tendríamos: 

\begin{equation}
    T(n) = \sum_{i=0}^{n-1} t + c = t \sum_{i=0}^{n-1} 1 + c = tn + c \implies \boxed{T(n) \in O(n)}
\end{equation}

\subsubsection{Caso Divide y Vencerás}

En esta parte, como consecuencia de los lemas \ref{lem:1} y \ref{lem:2}, podemos emplear un 
algoritmo similar al de búsqueda binaria (un caso muy particular de Divide y Vencerás: la
\textbf{simplificación} \cite{Verdegay2017}). Un ejemplo de \textbf{pseudocódigo} se puede encontrar en \ref{alg:1a-dyv} y
una \textbf{implementación} en \ref{cod:1a-dyv}.

\subsubsubsection{Pseudocódigo}

\lstinputlisting[caption=Pseudocódigo asociado al caso Divide y Vencerás., label={alg:1a-dyv}]{listing/ejer1a-pseudo-dyv.txt}

\subsubsubsection{Implementación}

\lstinputlisting[language=C++, firstline=117, lastline=130, 
caption=Implementación en C++ del algoritmo basado en Divide y Vencerás., label={cod:1a-dyv}]
{../src/ejercicio-1-comp-fija-no-repetidos.cpp} 

\subsubsubsection{Determinación del umbral}

\subsubsubsection{Análisis de Eficiencia}

Tenemos una estructura condicional. Si el tamaño del problema (número de componentes del vector donde 
vamos a buscar) es menor o igual que el UMBRAL escogido, entonces ejecutamos la BUSQUEDA\_LINEAL, que es $O(n)$. 
En caso contrario, calculamos $k$, proceso que es $O(1)$ y se acota por una contante $c$. 

A continuación, comprobamos si hemos encontrado el elemento o no. Como estamos realizando un análisis asintótico, supondremos
el peor de los casos, en el que no encontramos el elemento, por tanto, como se ha mencionado anteriormente,
se efectúa una simplificación realizándose una llamada recursiva para la mitad del vector correspondiente.

En conclusión, el análisis quedaría (supondremos que $n$ es potencia de 2, ya que podemos realizar una acotación 
superior de $n$ por la potencia de dos más cercana al estudiar la eficiencia $Big O$): 

\begin{equation}
    T(n) = \left\{ \begin{array}{lr} T(n/2) + c & \text{si } n > \text{UMBRAL}\\ n & \text{si } n \leqslant \text{UMBRAL} \end{array} \right.
\end{equation}

Vamos a resolver la recurrencia:

\begin{equation}
    \begin{array}{lr}  T(n) =  T(n/2) + c & \text{si } n > \text{UMBRAL} \end{array}
    \label{eq:ejer1:efi-dyv}
\end{equation}

Realizamos el cambio de variable $n = 2^{m}$ en la ecuación \ref{eq:ejer1:efi-dyv} obtenemos:

\begin{equation*}
    T(2^{m}) =  T(2^{m-1}) + c 
\end{equation*}

Renombramos la expresión anterior como $T(2^{m}) = t_{m}$, de donde obtenemos: $t_{m} - t_{m-1} = c$, con
ecuación característica asociada a la homogénea $(x-1)^{2} = 0$. Por tanto las soluciones son de la forma: 

\begin{equation*}
    t_{m} = c_{1} + c_{2}m
\end{equation*}

Deshacemos el cambio de variable:

\begin{equation}
    T(n) = c_{1} + c_{2} \log_2(n) \implies \boxed{T(n) \in O(\log_2(n))}
\end{equation}

En este caso, para tomar las medidas experimentales, hemos tomado para cada $n$ una \textbf{media de 1.000.000
de vectores diferentes}. Esto se debe a que el número de operaciones del algoritmo fluctúa mucho y puede terminar 
mucho antes o después en función
de los valores de entrada. \textbf{Para determinar este valor}, hemos probado con diferentes número de entradas, 
viendo que para este valor las salidas del tiempo de ejecución son más o menos \textbf{estables}. 

\subsubsection{Comparativa}

% CONCLUSIONES:
% - El método DyV proporciona un algoritmo más eficiente que el básico
% - Esto se ilustra en los resulados obtenidos empiricamente