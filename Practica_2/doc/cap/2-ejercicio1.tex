El \textbf{problema} que se nos plantea es, dado un vector ordenado (de forma no decreciente) de $n$ números enteros $v$, todos 
distintos, determinar si existe un índice $i$ tal que $v[i] = i$ y 
encontrarlo en ese caso. Para resolver el problema hemos utilizado dos algoritmos, uno básico basado en 
la búsqueda lineal, y otro basado en la técnica de Divide y Vencerás. 

\subsection{Vector con valores no repetidos}

En primer lugar, abordamos el problema para vectores con valores no repetidos. Para esta parte
caben destacar los lemas \ref{lem:1} y \ref{lem:2}. 

% El último algoritmo se ha desarrollado a partir de un análisis detallado del 
% problema, a partir del cual hemos conseguido demostrar las siguientes proposiciones:

\begin{lemma}
    \label{lem:1}
    Sea i con $0 \leqslant i < n$ fijo, tal que $v[i]=i+k$, con $k \in \mathbb N$. 
    Entonces $v[j] \neq j$, $\forall j \in \mathbb N$ con $i < j < n$. 
\end{lemma}

\begin{proof}
    Razonemos por contradicción. Supongamos que para $j > i$ se 
    cumple que $v[j]=j$, entonces $\exists m \in \mathbb N$ tal que $j=i+m$. Como el 
    vector está ordenado en orden no decreciente sin repetidos, como mínimo un elemento
    difiere en una unidad del elemento siguiente. Supongamos sin lugar a ambiguedad que
    se da la situación anterior para todo elemento en el vector, luego $v[j]=v[i]+m$. Como por hipótesis
    $v[i]=i+k$, tendríamos que $v[j]=i+k+m$, pero $i=j-m$, entonces $v[j]=j-m+k+m=j+k$, lo
    cual es una clara contradicción, ya que habiamos supuesto que $v[j]=j$. Por tanto, no 
    existe ningún $j$ tal que $v[j]=j$.
\end{proof}

\begin{lemma}
    \label{lem:2}
    Sea i con $0 < i < n$ fijo, tal que $v[i]=i-k$ con 
    $k \in \mathbb N$, entonces $v[j] \neq j$,  $\forall j$ con $0 \leqslant j < i$. 
\end{lemma}

\begin{proof}
    Razonemos por contradicción. Supongamos que para $j < i$ se 
    cumple que $v[j]=j$, entonces $\exists m \in \mathbb N$ tal que $j=i-m$. Como el 
    vector está ordenado en orden no decreciente sin repetidos, como mínimo un elemento
    difiere en una unidad del elemento siguiente. Podemos considerar esto último sin 
    lugar a ambiguedad para todo elemento del vector, luego $v[j]=v[i]-m$. Como por hipótesis
    $v[i]=i-k$, tendríamos que $v[j]=i-k-m$, pero $i=j+m$, entonces $v[j]=j+m-k-m=j-k$, lo
    cual es una clara contradicción, ya que habiamos supuesto que $v[j]=j$. Por tanto, no 
    existe ningún $j$ tal que $v[j]=j$.
\end{proof}

\subsubsection{Caso obvio}

En este caso el algoritmo de búsqueda del índice se basa en la búsqueda lineal. 

\begin{lstlisting}
BUSQUEDA_LINEAL(v[1...n-1], ini, fin)
    indice = ini
    si el tamaño del vector es mayor que 0
        para i = ini hasta fin o hasta que encontremos la posición
            si v[i] es igual a i (encontramos la posición)
                indice = i
    devolver indice
\end{lstlisting}

\lstinputlisting[language=C++, firstline=93, lastline=106, caption=Implementación en C++ del algoritmo basado en la búsqueda lineal.]{../src/ejercicio-1-comp-fija-no-repetidos.cpp} 

\paragraph{Eficiencia teórica}

En las líneas 94-95 tenemos sentencias de asignación que son $O(1)$, luego podemos acotarlas por una constante $c$. 
En las líneas 97-103 nos encontramos con un bucle while, que en el peor de los casos (no se encuentra la posición buscada) 
recorre todas las componentes del vector, en cuyo cuerpo encontramos sentencias $O(1)$, y las acotamos por una contante $t$.
Entonces llamando $n$ a la longitud del vector donde realizamos la búsqueda (el tamaño del problema) tendríamos: 

\begin{equation*}
    \sum_{i=0}^{n-1} t + c = t \sum_{i=0}^{n-1} 1 + c = tn + c
\end{equation*}

Luego la eficiencia de la BUSQUEDA_LINEAL es $O(n)$.

\subsubsection{Caso Divide y Vencerás}

En esta parte, como consecuencia de los lemas \ref{lem:1} y \ref{lem:2}, el algoritmo presentado es similar 
al algoritmo de búsqueda binaria (un caso muy particular de Divide y Vencerás, 
llamado \textbf{simplificación} \cite{Verdegay2017}).

En este caso, para tomar las medidas experimentales, se ha tenido que tomar para cada $n$ una \textbf{media de 1.000.000
de valores}. Esto se debe a que el nº de operaciones del algoritmo fluctúa mucho y puede terminar mucho antes o después en función
de los valores de entrada. \textbf{Para determinar este valor}, hemos probado con diferentes número de entradas, 
viendo que para este valor las salidas del tiempo de ejecución son más o menos \textbf{estables}. 

\begin{lstlisting}
BUSQUEDA_DV(v[1...n-1], ini, fin)
inicio
si (fin - ini + 1) <= UMBRAL 
    Devolver BUSQUEDA_LINEAL(v[1...n-1], ini, fin)
en caso contrario
    k = (ini + fin + 1)/2
    si v[k] == k
        Devolver k
        de lo contrario, si v[k]>k
            Devolver BUSQUEDA_DV(V[1...n-1], ini, k-1)
            de lo contrario
                Devolver  BUSQUEDA_DV(V[1...n-1], k+1, fin)
fin
\end{lstlisting}

\lstinputlisting[language=C++, firstline=117, lastline=130, caption=Implementación en C++ del algoritmo basado en la búsqueda lineal.]{../src/ejercicio-1-comp-fija-no-repetidos.cpp} 

\paragraph{Eficiencia teórica}

Tenemos una estructura condicional. Si el tamaño del problema (número de componentes del vector donde 
vamos a buscar) es menor o igual que el UMBRAL escogido, entonces ejecutamos la BUSQUEDA_LINEAL, que es $O(n)$. 
En caso contrario, calculamos $k$, proceso que es $O(1)$ y se acota por una contante $c$. A continuación,
comprobamos si hemos encontrado el elemento o no. Como estamos realizando un análisis asintótico, supondremos
el peor de los casos, en el que no encontramos el elemento, por tanto, como se ha mencionado anteriormente,
se efectúa una simplificación realizándose una llamada recursiva para la mitad del vector correspondiente.
En conclusión, el análisis quedaría (supondremos que $n$ es potencia de 2, ya que podemos realizar una acotación 
superior de $n$ por la potencia de dos más cercana al estudiar la eficiencia $Big O$): 

\begin{equation}
    T(n) = \left\{ \begin{array}{lr} T(n/2) + c & \text{si } n > \text{UMBRAL}\\ n & \text{si } n \leqslant \text{UMBRAL} \end{array} \right.
\end{equation}

Vamos a resolver la recurrencia:

\begin{equation*}
    \begin{array}{lr}  T(n) =  T(n/2) + c & \text{si } n > \text{UMBRAL} \end{array}
\end{equation*}

Realizamos el cambio de variable $n = 2^{m}$ en la ecuación (2) obtenemos:

\begin{equation*}
    T(2^{m}) =  T(2^{m-1}) + c 
\end{equation*}

Renombramos la expresión anterior como $T(2^{m}) = t_{m}$ obtenemos:

\begin{equation*}
    t_{m} - t_{m-1} = c 
\end{equation*}

Obtenemos la siguiente ecuación de recurrencia de la ecuación anterior:

\begin{equation}
    (x-1)^{2} = 0
\end{equation}

Luego la solución general de la recurrencia es:

\begin{equation}
    t_{m} = c_{1} + c_{2}m
\end{equation}

Deshacemos el cambio de variable:

\begin{equation}
    T(n) = c_{1} + c_{2}log_{2}(n)
\end{equation}

Por tanto $T(n) \in O(log_{2}(n))$ si $n >$ UMBRAL.

% CONCLUSIONES:
% - El método DyV proporciona un algoritmo más eficiente que el básico
% - Esto se ilustra en los resulados obtenidos empiricamente