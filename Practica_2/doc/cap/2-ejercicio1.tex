El \textbf{problema} que se nos plantea es, dado un vector ordenado (de forma no decreciente) de $n$ números enteros $v$, todos 
distintos, determinar si existe un índice $i$ tal que $v[i] = i$ y 
encontrarlo en ese caso. Para resolver el problema hemos utilizado dos algoritmos, uno básico basado en 
la búsqueda lineal, y otro basado en la técnica de Divide y Vencerás. 

\subsection{Vector con valores no repetidos}

En primer lugar, abordamos el problema para vectores con valores no repetidos. Para esta parte
caben destacar los lemas \ref{lem:1} y \ref{lem:2}. En esta subsección, $v$ será un vector ordenado con
valores no repetidos con componentes enteras. 

% El último algoritmo se ha desarrollado a partir de un análisis detallado del 
% problema, a partir del cual hemos conseguido demostrar las siguientes proposiciones:

\begin{lemma}
    \label{lem:1}
    Sea i con $0 \leqslant i < n$ fijo, tal que $v[i]=i+k$, con $k \in \mathbb N$. 
    Entonces $v[j] \neq j$, $\forall j \in \mathbb N$ con $i < j < n$. 
\end{lemma}

\begin{proof}
    Razonemos por contradicción. Supongamos que para $j > i$ se 
    cumple que $v[j]=j$, esto es, $\exists m \in \mathbb N$ tal que $j=i+m$. Como el 
    vector está ordenado en orden no decreciente sin repetidos, como mínimo un elemento
    difiere en una unidad del elemento siguiente. En consecuencia,  $v[j] \geq v[i]+m$. 
    Como por hipótesis $v[i]=i+k$, tendríamos que $v[j] \geq i+k+m$, pero $i=j-m$, entonces 
    $v[j] \geq j-m+k+m=j+k > j$, lo que es contradictorio pues habíamos supuesto que $v[j]=j$. Por tanto, no 
    existe ningún $j > i$ tal que $v[j]=j$.
\end{proof}

\begin{lemma}
    \label{lem:2}
    Sea i con $0 < i < n$ fijo, tal que $v[i]=i-k$ con 
    $k \in \mathbb N$. Entonces $v[j] \neq j$,  $\forall j$ con $0 \leqslant j < i$. 
\end{lemma}

\begin{proof}
    Razonemos por contradicción. Supongamos que para $j < i$ se 
    cumple que $v[j]=j$, entonces $\exists m \in \mathbb N$ tal que $j=i-m$. Como el 
    vector está ordenado en orden no decreciente sin repetidos, como mínimo un elemento
    difiere en una unidad del elemento siguiente. En consecuencia,  $v[j] \leq v[i]-m$. 
    Como por hipótesis $v[i]=i-k$, tendríamos que $v[j] \leq i-k-m$, pero $i=j+m$, entonces 
    $v[j] \leq j+m-k-m=j-k < j$, lo que es contradictorio pues habíamos supuesto que $v[j]=j$. Por tanto, no 
    existe ningún $j<i$ tal que $v[j]=j$.
\end{proof}

\subsubsection{Caso obvio}

En este caso el algoritmo de búsqueda del índice se basa en la búsqueda lineal. Un ejemplo de \textbf{pseudocódigo} 
se puede encontrar en \ref{alg:1a-obvio} y una \textbf{implementación} en \ref{cod:1a-obvio}.

\subsubsubsection{Pseudocódigo}

\lstinputlisting[caption=Pseudocódigo asociado al caso obvio., label={alg:1a-obvio}]{listing/ejer1a-pseudo-obvio.txt}

\subsubsubsection{Implementación}

\lstinputlisting[language=C++, firstline=93, lastline=106, caption=Implementación en C++ 
del algoritmo basado en la búsqueda lineal., label={cod:1a-obvio}]{../src/ejercicio-1-comp-fija-no-repetidos.cpp} 

\subsubsubsection{Análisis de Eficiencia}

Las dos primeras líneas son sentencias de asignación $O(1)$, luego podemos acotarlas por una constante $c$. 
Posteriormente, nos encontramos con un bucle while, que en el peor de los casos (no se encuentra la posición buscada) 
recorre todas las componentes del vector, en cuyo cuerpo encontramos sentencias $O(1)$, y las acotamos por una constante $t$.
Entonces llamando $n$ a la longitud del vector donde realizamos la búsqueda (el tamaño del problema) tendríamos: 

\begin{equation}
    T(n) = \sum_{i=0}^{n-1} t + c = t \sum_{i=0}^{n-1} 1 + c = tn + c \implies \boxed{T(n) \in O(n)}
\end{equation}

\subsubsection{Caso Divide y Vencerás}

En esta parte, como consecuencia de los lemas \ref{lem:1} y \ref{lem:2}, podemos emplear un 
algoritmo similar al de búsqueda binaria (un caso muy particular de Divide y Vencerás: la
\textbf{simplificación} \cite{Verdegay2017}). Un ejemplo de \textbf{pseudocódigo} se puede encontrar en \ref{alg:1a-dyv} y
una \textbf{implementación} en \ref{cod:1a-dyv}.

\subsubsubsection{Pseudocódigo}

\lstinputlisting[caption=Pseudocódigo asociado al caso Divide y Vencerás., label={alg:1a-dyv}]{listing/ejer1a-pseudo-dyv.txt}

\subsubsubsection{Implementación}

\lstinputlisting[language=C++, firstline=117, lastline=131, 
caption=Implementación en C++ del algoritmo basado en Divide y Vencerás., label={cod:1a-dyv}]
{../src/ejercicio-1-comp-fija-no-repetidos.cpp} 

\subsubsubsection{Determinación del umbral}

Un algoritmo Divide y Vencerás debe evitar proceder de forma recursiva cuando el tamaño de los subcasos no lo justifique, ya que
de lo contrario su rendimiento se degrada considerablemente. Esta es la razón por la cual debemos elegir un umbral, es decir, 
un tamaño del problema determinado tal que para un número de datos menor o igual que este, el algoritmo recursivo realize una 
llamada al algoritmo básico para resolver el problema. 

En nuestro caso, para encontrar dicho umbral, hemos de determinar el número de datos óptimo tales que para valores menores que este, 
el algoritmo básico presente mejores tiempos de ejecución que el algoritmo Divide y Vencerás. El cálculo del umbral depende en gran 
medida de las constantes ocultas, luego es dificil hacer un cáculo fiel a nivel teórico, por lo que se opta por adoptar un punto de 
vista teórico/empírico, mediante el cual, a partir de las implementaciones ejecutadas en un equipo concreto, \textbf{obtenemos las 
funciones de ajuste de ambos algoritmos con sus correspondientes parámetros}, y una vez obtenidas, \textbf{calculamos el umbral de 
forma teórica igualando ambas funciones, despejando el tamaño del problema}: 

%% Aquí vendría el desarrollo para los datos obtenidos

\subsubsubsection{Análisis de Eficiencia}

Tenemos una estructura condicional. Si el tamaño del problema (número de componentes del vector donde 
vamos a buscar) es menor o igual que el UMBRAL escogido, entonces ejecutamos la BUSQUEDA\_LINEAL, que es $O(n)$. 
En caso contrario, calculamos $k$, proceso que es $O(1)$ y se acota por una contante $c$. 

A continuación, comprobamos si hemos encontrado el elemento o no. Como estamos realizando un análisis asintótico, supondremos
el peor de los casos, en el que no encontramos el elemento, por tanto, como se ha mencionado anteriormente,
se efectúa una simplificación realizándose una llamada recursiva para la mitad del vector correspondiente.

En conclusión, el análisis quedaría (supondremos que $n$ es potencia de 2, ya que podemos realizar una acotación 
superior de $n$ por la potencia de dos más cercana al estudiar la eficiencia $Big O$): 

\begin{equation}
    T(n) = \left\{ \begin{array}{lr} T(n/2) + c & \text{si } n > \text{UMBRAL}\\ n & \text{si } n \leqslant \text{UMBRAL} \end{array} \right.
\end{equation}

Vamos a resolver la recurrencia:

\begin{equation}
    \begin{array}{lr}  T(n) =  T(n/2) + c & \text{si } n > \text{UMBRAL} \end{array}
    \label{eq:ejer1:efi-dyv}
\end{equation}

Realizamos el cambio de variable $n = 2^{m}$ en la ecuación \ref{eq:ejer1:efi-dyv} y obtenemos:

\begin{equation*}
    T(2^{m}) =  T(2^{m-1}) + c 
\end{equation*}

Renombramos la expresión anterior como $T(2^{m}) = t_{m}$, de donde obtenemos: $t_{m} - t_{m-1} = c$, con
ecuación característica asociada a la homogénea $(x-1)^{2} = 0$. Por tanto las soluciones son de la forma: 

\begin{equation*}
    t_{m} = c_{1} + c_{2}m
\end{equation*}

Deshacemos el cambio de variable:

\begin{equation}
    T(n) = c_{1} + c_{2} \log_2(n) \implies \boxed{T(n) \in O(\log_2(n))}
\end{equation}

En este caso, para tomar las medidas experimentales, hemos tomado para cada $n$ una \textbf{media de 1.000.000
de vectores diferentes}. Esto se debe a que el número de operaciones del algoritmo fluctúa mucho y puede terminar 
mucho antes o después en función
de los valores de entrada. \textbf{Para determinar este valor}, hemos probado con diferente número de entradas, 
viendo que para este valor las salidas del tiempo de ejecución son más o menos \textbf{estables}. 

\subsubsection{Comparativa}

El algoritmo que hace uso de la técnica Divide y Vencerás tiene un orden de eficiencia logarítmico, mientras
que la eficiencia del algoritmo básico es lineal, luego \textbf{se mejora notablemente la eficiencia usando la técnica de 
Divide y Vencerás} para solventar el problema. 

Este hecho se ilustra a partir de las gráficas correspondientes a los resultados empíricos obtenidos.   %+comment